{"version":3,"sources":["../../src/entity/bignumber.ts","../../src/common/convert-json.ts","../../src/common/pubkey.ts","../../src/common/logger.ts","../../src/version.ts","../../src/common/inspect.ts","../../src/common/web3.ts","../../src/entity/constant.ts"],"sourcesContent":["import BN from \"bn.js\";\n\nimport { Logger } from \"../common\";\n\nimport { TEN } from \"./constant\";\n\nconst logger = Logger.from(\"entity/bignumber\");\n\nexport type BigNumberish = BN | string | number | bigint;\n\nconst MAX_SAFE = 0x1fffffffffffff;\n\nexport function parseBigNumberish(value: BigNumberish) {\n  // BN\n  if (value instanceof BN) {\n    return value;\n  }\n\n  // string\n  if (typeof value === \"string\") {\n    if (value.match(/^-?[0-9]+$/)) {\n      return new BN(value);\n    }\n\n    return logger.throwArgumentError(\"invalid BigNumberish string\", \"value\", value);\n  }\n\n  // number\n  if (typeof value === \"number\") {\n    if (value % 1) {\n      return logger.throwArgumentError(\"BigNumberish number underflow\", \"value\", value);\n    }\n\n    if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n      return logger.throwArgumentError(\"BigNumberish number overflow\", \"value\", value);\n    }\n\n    return new BN(String(value));\n  }\n\n  // bigint\n  if (typeof value === \"bigint\") {\n    return new BN(value.toString());\n  }\n\n  return logger.throwArgumentError(\"invalid BigNumberish value\", \"value\", value);\n}\n\nexport function tenExponentiate(shift: BigNumberish) {\n  return TEN.pow(parseBigNumberish(shift));\n}\n\n// round up\nexport function divCeil(a: BN, b: BN): BN {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  const dm = a.divmod(b);\n\n  // Fast case - exact division\n  if (dm.mod.isZero()) return dm.div;\n\n  // Round up\n  return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { validateAndParsePublicKey } from \"./pubkey\";\n\ntype Primitive = boolean | number | string | null | undefined | PublicKey;\n\n/**\n *\n * @example\n * ```typescript\n * interface A {\n *   keyA: string;\n *   keyB: string;\n *   map: {\n *     hello: string;\n *     i: number;\n *   };\n *   list: (string | number)[];\n *   keyC: number;\n * }\n *\n * type WrappedA = ReplaceType<A, string, boolean> // {\n *   keyA: boolean;\n *   keyB: boolean;\n *   map: {\n *     hello: boolean;\n *     i: number;\n *   };\n *   list: (number | boolean)[];\n *   keyC: number;\n * }\n * ```\n */\nexport type ReplaceType<Old, From, To> = {\n  [T in keyof Old]: Old[T] extends From // to avoid case: Old[T] is an Object,\n    ? Exclude<Old[T], From> | To // when match,  directly replace\n    : Old[T] extends Primitive // judge whether need recursively replace\n    ? From extends Old[T] // it's an Object\n      ? Exclude<Old[T], From> | To // directly replace\n      : Old[T] // stay same\n    : ReplaceType<Old[T], From, To>; // recursively replace\n};\n\nexport function jsonInfo2PoolKeys<T>(jsonInfo: T): ReplaceType<T, string, PublicKey> {\n  // @ts-expect-error no need type for inner code\n  return Object.entries(jsonInfo).reduce((result, [key, value]) => {\n    if (typeof value === \"string\") {\n      result[key] = validateAndParsePublicKey(value);\n    } else if (value instanceof Array) {\n      result[key] = value.map((k) => validateAndParsePublicKey(k));\n    } else {\n      result[key] = value;\n    }\n\n    return result;\n  }, {});\n}\n\nexport function poolKeys2JsonInfo<T>(jsonInfo: T): ReplaceType<T, PublicKey, string> {\n  // @ts-expect-error no need type for inner code\n  return Object.entries(jsonInfo).reduce((result, [key, value]) => {\n    if (value instanceof PublicKey) {\n      result[key] = value.toBase58();\n    } else if (value instanceof Array) {\n      result[key] = value.map((k) => k.toBase58());\n    } else {\n      result[key] = value;\n    }\n\n    return result;\n  }, {});\n}\n","import { PublicKey, SystemProgram } from \"@solana/web3.js\";\n\nimport { Logger } from \"./logger\";\n\nconst logger = Logger.from(\"common/pubkey\");\n\n/* ================= global public keys ================= */\nexport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nexport { SYSVAR_CLOCK_PUBKEY, SYSVAR_RENT_PUBKEY } from \"@solana/web3.js\";\n\nexport const SYSTEM_PROGRAM_ID = SystemProgram.programId;\nexport const MEMO_PROGRAM_ID = new PublicKey(\"Memo1UhkJRfHyvLMcVucJwxXeuD728EqVDDwQDxFMNo\");\n\n/* ================= validate public key ================= */\nexport type PublicKeyish = PublicKey | string;\n\nexport function validateAndParsePublicKey(publicKey: PublicKeyish) {\n  if (publicKey instanceof PublicKey) {\n    return publicKey;\n  }\n\n  if (typeof publicKey === \"string\") {\n    try {\n      const key = new PublicKey(publicKey);\n      return key;\n    } catch {\n      return logger.throwArgumentError(\"invalid public key\", \"publicKey\", publicKey);\n    }\n  }\n\n  return logger.throwArgumentError(\"invalid public key\", \"publicKey\", publicKey);\n}\n\nexport async function findProgramAddress(seeds: Array<Buffer | Uint8Array>, programId: PublicKey) {\n  const [publicKey, nonce] = await PublicKey.findProgramAddress(seeds, programId);\n  return { publicKey, nonce };\n}\n\nexport function AccountMeta(publicKey: PublicKey, isSigner: boolean) {\n  return {\n    pubkey: publicKey,\n    isWritable: true,\n    isSigner,\n  };\n}\n\nexport function AccountMetaReadonly(publicKey: PublicKey, isSigner: boolean) {\n  return {\n    pubkey: publicKey,\n    isWritable: false,\n    isSigner,\n  };\n}\n","import { PublicKey } from \"@solana/web3.js\";\n\nimport { version } from \"../version\";\n\n// https://github.com/DABH/colors.js\nimport \"@colors/colors\";\n\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\n\nconst LogLevels: { [name: string]: number } = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };\nconst _moduleLogLevel: { [name: string]: number } = {};\n\nlet _globalLogger: Logger;\n\nfunction _checkNormalize(): string {\n  try {\n    const missing: Array<string> = [];\n\n    // Make sure all forms of normalization are supported\n    [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n      try {\n        if (\"test\".normalize(form) !== \"test\") {\n          throw new Error(\"bad normalize\");\n        }\n      } catch (error) {\n        missing.push(form);\n      }\n    });\n\n    if (missing.length) {\n      throw new Error(\"missing \" + missing.join(\", \"));\n    }\n\n    if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n      throw new Error(\"broken implementation\");\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      return error.message;\n    }\n  }\n\n  return \"\";\n}\n\nconst _normalizeError = _checkNormalize();\n\nexport enum LogLevel {\n  DEBUG = \"DEBUG\",\n  INFO = \"INFO\",\n  WARNING = \"WARNING\",\n  ERROR = \"ERROR\",\n  OFF = \"OFF\",\n}\n\nexport enum ErrorCode {\n  ///////////////////\n  // Generic Errors\n\n  // Unknown Error\n  UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n\n  // Not Implemented\n  NOT_IMPLEMENTED = \"NOT_IMPLEMENTED\",\n\n  // Unsupported Operation\n  //   - operation\n  UNSUPPORTED_OPERATION = \"UNSUPPORTED_OPERATION\",\n\n  // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n  //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n  NETWORK_ERROR = \"NETWORK_ERROR\",\n\n  // Some sort of bad response from the server\n  RPC_ERROR = \"RPC_ERROR\",\n\n  // Timeout\n  TIMEOUT = \"TIMEOUT\",\n\n  ///////////////////\n  // Operational  Errors\n\n  // Buffer Overrun\n  BUFFER_OVERRUN = \"BUFFER_OVERRUN\",\n\n  // Numeric Fault\n  //   - operation: the operation being executed\n  //   - fault: the reason this faulted\n  NUMERIC_FAULT = \"NUMERIC_FAULT\",\n\n  ///////////////////\n  // Argument Errors\n\n  // Missing new operator to an object\n  //  - name: The name of the class\n  MISSING_NEW = \"MISSING_NEW\",\n\n  // Invalid argument (e.g. value is incompatible with type) to a function:\n  //   - argument: The argument name that was invalid\n  //   - value: The value of the argument\n  INVALID_ARGUMENT = \"INVALID_ARGUMENT\",\n\n  // Missing argument to a function:\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n  MISSING_ARGUMENT = \"MISSING_ARGUMENT\",\n\n  // Too many arguments\n  //   - count: The number of arguments received\n  //   - expectedCount: The number of arguments expected\n  UNEXPECTED_ARGUMENT = \"UNEXPECTED_ARGUMENT\",\n\n  ///////////////////\n  // Blockchain Errors\n\n  // Insufficien funds (< value + gasLimit * gasPrice)\n  //   - transaction: the transaction attempted\n  INSUFFICIENT_FUNDS = \"INSUFFICIENT_FUNDS\",\n}\n\nconst HEX = \"0123456789abcdef\";\n\nfunction perfectDisplay(value: any, deeping = false) {\n  let _value = value;\n\n  try {\n    if (value instanceof Uint8Array) {\n      let hex = \"\";\n      for (let i = 0; i < value.length; i++) {\n        hex += HEX[value[i] >> 4];\n        hex += HEX[value[i] & 0x0f];\n      }\n      _value = `Uint8Array(0x${hex})`;\n    } else if (value instanceof PublicKey) {\n      _value = `PublicKey(${value.toBase58()})`;\n    } else if (value instanceof Object && !deeping) {\n      const obj = {};\n      Object.entries(value).forEach(([k, v]) => {\n        obj[k] = perfectDisplay(v, true);\n      });\n      _value = JSON.stringify(obj);\n    } else if (!deeping) {\n      _value = JSON.stringify(value);\n    }\n  } catch (error) {\n    _value = JSON.stringify(value.toString());\n  }\n\n  return _value;\n}\n\nexport class Logger {\n  readonly version: string = version;\n  readonly moduleName: string;\n\n  static errors = ErrorCode;\n\n  static levels = LogLevel;\n\n  constructor(moduleName: string) {\n    this.moduleName = moduleName;\n  }\n\n  _log(logLevel: LogLevel, args: Array<any>): void {\n    const level = logLevel.toLowerCase();\n    if (LogLevels[level] == null) {\n      this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n    }\n    const _logLevel = _moduleLogLevel[this.moduleName] || LogLevels[\"default\"];\n    if (_logLevel > LogLevels[level]) {\n      return;\n    }\n    console.log(...args);\n  }\n\n  debug(...args: Array<any>): void {\n    this._log(Logger.levels.DEBUG, [\"[DEBUG]\".blue, ...args]);\n  }\n\n  info(...args: Array<any>): void {\n    this._log(Logger.levels.INFO, [\"[INFO]\".green, ...args]);\n  }\n\n  warn(...args: Array<any>): void {\n    this._log(Logger.levels.WARNING, [\"[WARN]\".yellow, ...args]);\n  }\n\n  makeError(message: string, code?: ErrorCode, params?: any): Error {\n    // Errors are being censored\n    if (_censorErrors) {\n      return this.makeError(\"censored error\", code, {});\n    }\n\n    if (!code) {\n      code = Logger.errors.UNKNOWN_ERROR;\n    }\n    if (!params) {\n      params = {};\n    }\n\n    const messageDetails: Array<string> = [];\n    Object.entries(params).forEach(([key, value]) => {\n      messageDetails.push(`${key}=${perfectDisplay(value)})`);\n    });\n    messageDetails.push(`code=${code}`);\n    messageDetails.push(`module=${this.moduleName}`);\n    messageDetails.push(`version=${this.version}`);\n\n    const reason = message;\n    if (messageDetails.length) {\n      message += \" (\" + messageDetails.join(\", \") + \")\";\n    }\n\n    // @TODO: Any??\n    const error: any = new Error(message);\n    error.reason = reason;\n    error.code = code;\n\n    Object.entries(params).forEach(([key, value]) => {\n      error[key] = value;\n    });\n\n    return error;\n  }\n\n  throwError(message: string, code?: ErrorCode, params?: any): never {\n    throw this.makeError(message, code, params);\n  }\n\n  throwArgumentError(message: string, name: string, value: any): never {\n    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n      argument: name,\n      value,\n    });\n  }\n\n  assert(condition: any, message: string, code?: ErrorCode, params?: any): void {\n    if (condition) {\n      return;\n    }\n    this.throwError(message, code, params);\n  }\n\n  assertArgument(condition: any, message: string, name: string, value: any): void {\n    if (condition) {\n      return;\n    }\n    this.throwArgumentError(message, name, value);\n  }\n\n  checkNormalize(message?: string): void {\n    if (message == null) {\n      message = \"platform missing String.prototype.normalize\";\n    }\n    if (_normalizeError) {\n      this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"String.prototype.normalize\",\n        form: _normalizeError,\n      });\n    }\n  }\n\n  checkSafeUint53(value: number, message?: string): void {\n    if (typeof value !== \"number\") {\n      return;\n    }\n\n    if (message == null) {\n      message = \"value not safe\";\n    }\n\n    if (value < 0 || value >= 0x1fffffffffffff) {\n      this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"out-of-safe-range\",\n        value,\n      });\n    }\n\n    if (value % 1) {\n      this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n        operation: \"checkSafeInteger\",\n        fault: \"non-integer\",\n        value,\n      });\n    }\n  }\n\n  checkArgumentCount(count: number, expectedCount: number, message?: string): void {\n    if (message) {\n      message = \": \" + message;\n    } else {\n      message = \"\";\n    }\n\n    if (count < expectedCount) {\n      this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n        count,\n        expectedCount,\n      });\n    }\n\n    if (count > expectedCount) {\n      this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n        count,\n        expectedCount,\n      });\n    }\n  }\n\n  checkNew(target: any, kind: any): void {\n    if (target === Object || target == null) {\n      this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n    }\n  }\n\n  checkAbstract(target: any, kind: any): void {\n    if (target === kind) {\n      this.throwError(\n        \"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\",\n        Logger.errors.UNSUPPORTED_OPERATION,\n        { name: target.name, operation: \"new\" },\n      );\n    } else if (target === Object || target == null) {\n      this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n    }\n  }\n\n  static globalLogger(): Logger {\n    if (!_globalLogger) {\n      _globalLogger = new Logger(version);\n    }\n    return _globalLogger;\n  }\n\n  static setCensorship(censorship: boolean, permanent?: boolean): void {\n    if (!censorship && permanent) {\n      this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\",\n      });\n    }\n\n    if (_permanentCensorErrors) {\n      if (!censorship) {\n        return;\n      }\n      this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\",\n      });\n    }\n\n    _censorErrors = !!censorship;\n    _permanentCensorErrors = !!permanent;\n  }\n\n  static setLogLevel(moduleName: string, logLevel: \"DEBUG\" | \"INFO\" | \"WARNING\" | \"ERROR\" | \"OFF\"): void {\n    const level = LogLevels[logLevel.toLowerCase()];\n    if (level == null) {\n      Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n      return;\n    }\n    _moduleLogLevel[moduleName] = level;\n  }\n\n  static from(version: string): Logger {\n    return new Logger(version);\n  }\n}\n","export const version = \"1.1.0-beta.0\";\n","/* eslint-disable @typescript-eslint/ban-ts-comment */\n\nimport { PublicKey } from \"@solana/web3.js\";\nimport BN from \"bn.js\";\n\nexport function inspectPublicKey() {\n  if (typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\") {\n    try {\n      PublicKey.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function () {\n        return `<PublicKey: ${this.toString()}>`;\n      };\n    } catch (e) {\n      // @ts-ignore\n      PublicKey.prototype.inspect = function () {\n        return `<PublicKey: ${this.toString()}>`;\n      };\n    }\n  } else {\n    // @ts-ignore\n    PublicKey.prototype.inspect = function () {\n      return `<PublicKey: ${this.toString()}>`;\n    };\n  }\n}\n\nexport function inspectBN() {\n  if (typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\") {\n    try {\n      BN.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = function () {\n        // @ts-ignore\n        return `<${this.red ? \"BN-R\" : \"BN\"}: ${this.toString()}>`;\n      };\n    } catch (e) {\n      // @ts-ignore\n      BN.prototype.inspect = function () {\n        // @ts-ignore\n        return `<${this.red ? \"BN-R\" : \"BN\"}: ${this.toString()}>`;\n      };\n    }\n  } else {\n    // @ts-ignore\n    BN.prototype.inspect = function () {\n      // @ts-ignore\n      return `<${this.red ? \"BN-R\" : \"BN\"}: ${this.toString()}>`;\n    };\n  }\n}\n\nexport function inspectAll() {\n  inspectPublicKey();\n  inspectBN();\n}\n","// import BN from 'bn.js';\n\n// import { Spl, SPL_ACCOUNT_LAYOUT } from '../spl';\n// import { TOKEN_PROGRAM_ID } from './id';\n\nimport {\n  AccountInfo, Commitment, Connection, PACKET_DATA_SIZE, PublicKey, RpcResponseAndContext, SimulatedTransactionResponse,\n  Transaction, TransactionInstruction,\n} from \"@solana/web3.js\";\n\nimport { chunkArray } from \"./lodash\";\nimport { Logger } from \"./logger\";\n\nconst logger = Logger.from(\"common/web3\");\n\ninterface MultipleAccountsJsonRpcResponse {\n  jsonrpc: string;\n  id: string;\n  error?: {\n    code: number;\n    message: string;\n  };\n  result: {\n    context: { slot: number };\n    value: { data: Array<string>; executable: boolean; lamports: number; owner: string; rentEpoch: number }[];\n  };\n}\n\nexport interface GetMultipleAccountsInfoConfig {\n  batchRequest?: boolean;\n  commitment?: Commitment;\n}\n\n// export async function batchGetMultipleAccountsInfo() {}\n\nexport async function getMultipleAccountsInfo(\n  connection: Connection,\n  publicKeys: PublicKey[],\n  config?: GetMultipleAccountsInfoConfig,\n): Promise<(AccountInfo<Buffer> | null)[]> {\n  const { batchRequest, commitment } = {\n    // default\n    ...{\n      batchRequest: false,\n    },\n    // custom\n    ...config,\n  };\n\n  const chunkedKeys = chunkArray(publicKeys, 100);\n  let results: (AccountInfo<Buffer> | null)[][] = new Array(chunkedKeys.length).fill([]);\n\n  if (batchRequest) {\n    const batch = chunkedKeys.map((keys) => {\n      const args = connection._buildArgs([keys.map((key) => key.toBase58())], commitment, \"base64\");\n      return {\n        methodName: \"getMultipleAccounts\",\n        args,\n      };\n    });\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    const unsafeResponse: MultipleAccountsJsonRpcResponse[] = await connection._rpcBatchRequest(batch);\n    results = unsafeResponse.map((unsafeRes: MultipleAccountsJsonRpcResponse) => {\n      if (unsafeRes.error) {\n        return logger.throwError(\"failed to get info for multiple accounts\", Logger.errors.RPC_ERROR, {\n          message: unsafeRes.error.message,\n        });\n      }\n\n      return unsafeRes.result.value.map((accountInfo) => {\n        if (accountInfo) {\n          const { data, executable, lamports, owner, rentEpoch } = accountInfo;\n\n          if (data.length !== 2 && data[1] !== \"base64\") {\n            return logger.throwError(\"info must be base64 encoded\", Logger.errors.RPC_ERROR);\n          }\n\n          return {\n            data: Buffer.from(data[0], \"base64\"),\n            executable,\n            lamports,\n            owner: new PublicKey(owner),\n            rentEpoch,\n          };\n        } else {\n          return null;\n        }\n      });\n    });\n  } else {\n    try {\n      results = (await Promise.all(\n        chunkedKeys.map((keys) => connection.getMultipleAccountsInfo(keys, commitment)),\n      )) as (AccountInfo<Buffer> | null)[][];\n    } catch (error) {\n      if (error instanceof Error) {\n        return logger.throwError(\"failed to get info for multiple accounts\", Logger.errors.RPC_ERROR, {\n          message: error.message,\n        });\n      }\n    }\n  }\n\n  return results.flat();\n}\n\nexport async function getMultipleAccountsInfoWithCustomFlags<T extends { pubkey: PublicKey }>(\n  connection: Connection,\n  publicKeysWithCustomFlag: T[],\n  config?: GetMultipleAccountsInfoConfig,\n): Promise<({ accountInfo: AccountInfo<Buffer> | null } & T)[]> {\n  const multipleAccountsInfo = await getMultipleAccountsInfo(\n    connection,\n    publicKeysWithCustomFlag.map((o) => o.pubkey),\n    config,\n  );\n\n  return publicKeysWithCustomFlag.map((o, idx) => ({ ...o, accountInfo: multipleAccountsInfo[idx] }));\n}\n\nexport interface GetTokenAccountsByOwnerConfig {\n  commitment?: Commitment;\n}\n\n// export async function getTokenAccountsByOwner(\n//   connection: Connection,\n//   owner: PublicKey,\n//   config?: GetTokenAccountsByOwnerConfig\n// ) {\n//   const defaultConfig = {};\n//   const customConfig = { ...defaultConfig, ...config };\n\n//   const solReq = connection.getAccountInfo(owner, customConfig.commitment);\n//   const tokenReq = connection.getTokenAccountsByOwner(\n//     owner,\n//     {\n//       programId: TOKEN_PROGRAM_ID\n//     },\n//     customConfig.commitment\n//   );\n\n//   const [solResp, tokenResp] = await Promise.all([solReq, tokenReq]);\n\n//   const accounts: {\n//     publicKey?: PublicKey;\n//     mint?: PublicKey;\n//     isAssociated?: boolean;\n//     amount: BN;\n//     isNative: boolean;\n//   }[] = [];\n\n//   for (const { pubkey, account } of tokenResp.value) {\n//     // double check layout length\n//     if (account.data.length !== SPL_ACCOUNT_LAYOUT.span) {\n//       return logger.throwArgumentError('invalid token account layout length', 'publicKey', pubkey);\n//     }\n\n//     const { mint, amount } = SPL_ACCOUNT_LAYOUT.decode(account.data);\n//     const associatedTokenAddress = await Spl.getAssociatedTokenAddress({ mint, owner });\n\n//     accounts.push({\n//       publicKey: pubkey,\n//       mint,\n//       isAssociated: associatedTokenAddress.equals(pubkey),\n//       amount,\n//       isNative: false\n//     });\n//   }\n\n//   if (solResp) {\n//     accounts.push({\n//       amount: new BN(solResp.lamports),\n//       isNative: true\n//     });\n//   }\n\n//   return accounts;\n// }\n\n/**\n * Forecast transaction size\n */\nexport function forecastTransactionSize(instructions: TransactionInstruction[], signers: PublicKey[]) {\n  if (instructions.length < 1) {\n    return logger.throwArgumentError(\"no instructions provided\", \"instructions\", instructions);\n  }\n  if (signers.length < 1) {\n    return logger.throwArgumentError(\"no signers provided\", \"signers\", signers);\n  }\n\n  const transaction = new Transaction({\n    recentBlockhash: \"11111111111111111111111111111111\",\n    feePayer: signers[0],\n  });\n\n  transaction.add(...instructions);\n\n  const message = transaction.compileMessage().serialize();\n  // SIGNATURE_LENGTH = 64\n  const transactionLength = signers.length + signers.length * 64 + message.length;\n\n  return transactionLength;\n}\n\n/**\n * Simulates multiple instruction\n */\nexport async function simulateMultipleInstruction(\n  connection: Connection,\n  instructions: TransactionInstruction[],\n  keyword: string,\n) {\n  const feePayer = new PublicKey(\"RaydiumSimuLateTransaction11111111111111111\");\n\n  const transactions: Transaction[] = [];\n\n  let transaction = new Transaction({ feePayer });\n\n  for (const instruction of instructions) {\n    if (forecastTransactionSize([...transaction.instructions, instruction], [feePayer]) > PACKET_DATA_SIZE) {\n      transactions.push(transaction);\n      transaction = new Transaction({ feePayer });\n      transaction.add(instruction);\n    } else {\n      transaction.add(instruction);\n    }\n  }\n  if (transaction.instructions.length > 0) {\n    transactions.push(transaction);\n  }\n\n  let results: RpcResponseAndContext<SimulatedTransactionResponse>[] = [];\n\n  try {\n    results = await Promise.all(transactions.map((transaction) => connection.simulateTransaction(transaction)));\n  } catch (error) {\n    if (error instanceof Error) {\n      return logger.throwError(\"failed to simulate for instructions\", Logger.errors.RPC_ERROR, {\n        message: error.message,\n      });\n    }\n  }\n\n  const logs: string[] = [];\n  for (const result of results) {\n    const { value } = result;\n    logger.debug(\"simulate result:\", result);\n\n    if (value.logs) {\n      const filteredLog = value.logs.filter((log) => log && log.includes(keyword));\n      logger.debug(\"filteredLog:\", logs);\n\n      logger.assertArgument(filteredLog.length !== 0, \"simulate log not match keyword\", \"keyword\", keyword);\n\n      logs.push(...filteredLog);\n    }\n  }\n\n  return logs;\n}\n\nexport function parseSimulateLogToJson(log: string, keyword: string) {\n  const results = log.match(/{[\"\\w:,]+}/g);\n  if (!results || results.length !== 1) {\n    return logger.throwArgumentError(\"simulate log fail to match json\", \"keyword\", keyword);\n  }\n\n  return results[0];\n}\n\nexport function parseSimulateValue(log: string, key: string) {\n  const reg = new RegExp(`\"${key}\":(\\\\d+)`, \"g\");\n\n  const results = reg.exec(log);\n  if (!results || results.length !== 2) {\n    return logger.throwArgumentError(\"simulate log fail to match key\", \"key\", key);\n  }\n\n  return results[1];\n}\n","import BN from \"bn.js\";\n\nexport enum Rounding {\n  ROUND_DOWN,\n  ROUND_HALF_UP,\n  ROUND_UP,\n}\n\nexport const ZERO = new BN(0);\nexport const ONE = new BN(1);\nexport const TWO = new BN(2);\nexport const THREE = new BN(3);\nexport const FIVE = new BN(5);\nexport const TEN = new BN(10);\nexport const _100 = new BN(100);\nexport const _1000 = new BN(1000);\nexport const _10000 = new BN(10000);\n"],"mappings":"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","names":[]}